/**
 * Right now we have several ways to get, generate and pass the request id,
 * we will standarize using `traceparent` header and eventually everything should
 * be using it. This is an stopgap to abstract all the logic away so we can
 * use the headers we have today whereas at the same time we rollout and standarize on `traceparent`
 */

 // These are random values, something low enough to work in most cases and to prevent issues
 // at the same time
const MAX_AMZ_TRACING_HEADER_SEGMENTS = 10;
const MAX_AMZ_TRACING_HEADER_LENGTH = 500;

const TRACE_CONTEXT_SUPPORTED_VERSION = "00";

const constants = require('./constants');

/**
 * Utility to propagate request id to headers or other carriers, it allows us to change
 * the underlying implementation header name, etc. without having to change everything
 */
function forwardReqIdsToObjectCarrier(req, carrier) {
  if (typeof carrier !== 'object' || carrier === null) {
    return carrier;
  }

  // Forward x-amzn-trace-id
  if (!req || typeof req.headers !== 'object' || req.headers === null) {
    return carrier;
  }

  if (req.headers['x-amzn-trace-id']) {
    carrier['x-amzn-trace-id'] = req.headers['x-amzn-trace-id'];
  }

  // These are a headers to forward if available however we don't get the
  // if from them because they are generated by auth0-server for customer debugging,
  // should be slowly replaced by TraceContext
  if (req.headers['x-auth0-id']) {
    carrier['x-auth0-id'] = req.headers['x-auth0-id'];
  }

  return carrier;
}

function forwardReqIdsToSpan(req, span) {
  // We need to check for setBaggageItem because old versions of auth0-instrumentation used not to
  // implement it
  if (!span || typeof span.setBaggageItem !== 'function' || typeof span.getBaggageItem !== 'function') {
    return;
  }

  if (!span.getBaggageItem(constants.TAG_AUTH0_REQUEST_ID)) {
    const id = getIdFromReq(req);

    if (typeof id === 'string') {
      span.setBaggageItem(constants.TAG_AUTH0_REQUEST_ID, id);

      // Baggage items are not set as tags automatically by Lightstep (other implementations do)
      span.setTag(constants.TAG_AUTH0_REQUEST_ID, id);
    }
  }
}

/**
 * This function is useful to get the request id to log it for example, the
 * id might come from different sources at this point although we should tend to
 * end up using `traceparent` only
 */
function getIdFromReq(req) {
  if (!req) {
    return null;
  }

  if (typeof req.headers !== 'object' || req.headers === null) {
    return null;
  }

  const headers = req.headers;

  // TraceContext header https://w3c.github.io/trace-context/#considerations-for-trace-id-field-generation
  const traceParentId = parseTraceContext(headers['traceparent']);
  if (traceParentId) {
    return traceParentId;
  }

  // Stopgap until `traceparent` gets fully implemented since we are already forwarding this
  // header in many cases
  const amzId = parseAmazonTraceHeader(headers['x-amzn-trace-id']);
  if (amzId) {
    return amzId;
  }

  // Lastly this is the way suggested by Lightstep for us to propagate the id
  // We check if `getBaggageItem` is a function because older version of
  // auth0-instrumentation used not to implement that
  if (req && req.a0trace && req.a0trace.span && typeof req.a0trace.span.getBaggageItem === 'function') {
    const id = req.a0trace.span.getBaggageItem(constants.TAG_AUTH0_REQUEST_ID);

    if (id) {
      return id;
    }
  }

  return null;
};

/**
 * Parses traceparent header as defined by https://w3c.github.io/trace-context/#considerations-for-trace-id-field-generation
 */
function parseTraceContext(traceParent) {
  if (typeof traceParent !== 'string') {
    return;
  }

  const segments = traceParent.split('-');

  if (segments.length !== 4) {
    return;
  }

  const version = segments[0];

  // We only handle this version for now
  if (version !== TRACE_CONTEXT_SUPPORTED_VERSION) {
    return;
  }

  const traceId = segments[1];

  if (!traceId) {
    return;
  }

  return traceId;
}

function parseAmazonTraceHeader(amzHeader) {
  if (typeof amzHeader !== 'string') {
    return;
  }

  if (amzHeader.length > MAX_AMZ_TRACING_HEADER_LENGTH) {
    return;
  }

  // There might be more than one id https://docs.aws.amazon.com/elasticloadbalancing/latest/application/load-balancer-request-tracing.html
  // if the request passed through more than one LB
  const segments = amzHeader.split(';');

  // We put some limits to prevent issues
  if (segments.length > MAX_AMZ_TRACING_HEADER_SEGMENTS) {
    return;
  }

  const rootKV = segments.find((s) => {
    const keyvalue = s.split('=');

    return keyvalue.length === 2 && keyvalue[0].trim().toLowerCase() === 'root';
  });

  if (rootKV) {
    const kvSegments = rootKV.split('=');

    if (kvSegments.length !== 2) {
      return;
    }

    const valueSegments = kvSegments[1].split('-');

    if (!valueSegments || valueSegments.length !== 3) {
      return;
    }

    return valueSegments[2];
  }
}

exports.getIdFromReq = getIdFromReq;
exports.forwardReqIdsToObjectCarrier = forwardReqIdsToObjectCarrier;
exports.forwardReqIdsToSpan = forwardReqIdsToSpan;
